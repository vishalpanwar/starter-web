
<html>
<body>
<b>(a)Number Theory</b>
<ol>
	<li>Prime Number GenerationÂ  (Sieve, Segmented Sieve)</li>
	<li>Euler Totient Theorem</li>
	<li>Fermatâ€™s Theorem</li>
	<li>HCF &amp; LCM (Euclid)</li>
	<li>Linear Diophantine Equations (Extended Euclid)</li>
	<li>Modulus Arithmetic (addition,multiplication,subtraction,modular Inverse)</li>
	<li>Cycle Finding (Floyd Algo and Brent Algo)</li>
	<li>Integer Factorization (Trial Division , Pollard Rho method)</li>
	<li>Lucas TheoremÂ  (Simple &amp; Advance)</li>
	<li>Chinese Remainder Theorem</li>
	<li>Wilson Theorem</li>
	<li>Miller - Rabin Primality Testing</li>
	<li>Perfect Numbers</li>
	<li>Goldbach Conjecture</li>
</ol>
<b>(b)Probability</b>
<ol>
	<li>Basic Probability and Conditional Probability</li>
	<li>Random Variables</li>
	<li>Probability Generating Functions</li>
	<li>Expectation</li>
	<li>Probability Distribution [Binomial, Poisson, Normal,Bernoulli]</li>
</ol>
<b>(c)Counting</b>
<ol>
	<li>Pigeonhole principle</li>
	<li>Inclusion Exclusion</li>
	<li>Special NumbersÂ  [Stirling,Fibonacci,Catalan, Eulerian, Harmonic, Bernoulli]</li>
	<li>Polya Counting</li>
	<li>Burnside lemma</li>
</ol>
<b>(d)Permutation Cycles</b>

<b>(e)Linear Algebra</b>
<ol>
	<li>Addition And Subtraction Of Matrices</li>
	<li>Multiplication ( Strassen's algorithm ), Logarithmic exponentiation</li>
	<li>Matrix Transformations [ Transpose, Rotation Of Matrix, Representing Linear Transformations Using Matrix ]</li>
	<li>Determinant , Rank and Inverse Of Matrix [ Gaussian Elimination , Gauss Jordan Elimination]</li>
	<li>Solving System Of Linear Equations</li>
	<li>Matrix Exponentiation To Solve Recurrences</li>
	<li>Eigenvalues And Eigen vector</li>
	<li>Roots of a polynomial [ Prime factorization of a polynomial, Integer roots of a polynomial]</li>
	<li>Lagrange Interpolation</li>
</ol>
<b>(e)Game Theory</b>
<ol>
	<li>Basic Concepts &amp; Nim Game [Grundy Theorem , Grundy Number]</li>
	<li>Hackenbush</li>
</ol>
<b>(f)Group Theory</b>
<ol>
	<li>Burnside Lemma</li>
	<li>Polya's Theorem</li>
</ol>
<b>Graphs:</b>

<b>(a)Graph Representation</b>
<ol>
	<li>Adjacency Matrix</li>
	<li>Adjacency List</li>
	<li>Incidence Matrix</li>
	<li>Edge List</li>
</ol>
<b>(b)Graph Types</b>
<ol>
	<li>Directed</li>
	<li>Undirected</li>
	<li>Weighted</li>
	<li>Unweighted</li>
	<li>Planar</li>
	<li>Hamilton</li>
	<li>Euler</li>
	<li>Special Graphs</li>
</ol>
<b>(c)DFS &amp; Itâ€™s Application</b>
<ol>
	<li>Cycle Detection</li>
	<li>Articulation Points</li>
	<li>Bridges</li>
	<li>Strongly Connected Component</li>
	<li>Connected Component</li>
	<li>Path Finding</li>
	<li>Solving Maze</li>
	<li>Biconnectivity in Graph</li>
	<li>Topological Sorting</li>
	<li>Bipartite Checking</li>
	<li>Planarity Testing</li>
	<li>Flood-fill algorithm</li>
</ol>
<b>(d)BFS &amp; Itâ€™s Application</b>
<ol>
	<li>Shortest Path (No. Of Edges)</li>
	<li>Bipartite Checking</li>
	<li>Connected Components</li>
</ol>
<b>(d)Minimum Spanning Tree</b>
<ol>
	<li>Primâ€™s Algorithm</li>
	<li>Kruskal Algorithm</li>
</ol>
<b>(d)Single Source Shortest-Path </b>
<ol>
	<li>Dijkstra</li>
	<li>Bellman Ford</li>
</ol>
<b>(e)All pair Shortest Path</b>
<ol>
	<li>Floyd Warshallâ€™s Algorithm</li>
</ol>
<b>(f)Euler Tour</b>

<b>(g)Flow</b>
<ol>
	<li>Ford-Fulkerson [PFS,DFS,BFS]</li>
	<li>Dinic's Algorithm</li>
	<li>Min Cost - Max FlowÂ  [Successive Shortest Path Algo,Cycle Cancelling Algorithm]</li>
	<li>Max Weighted BPMÂ  [Kuhn Munkres algorithm/Hungarian Method]</li>
	<li>Stoer Wagner Min-Cut Algo</li>
	<li>Hop-Kraft BPM</li>
	<li>Edmond Blossom Shrinking Algorithm</li>
</ol>
<b>(h)Other Important Topics On Graphs</b>
<ol>
	<li>2-SAT,</li>
	<li>LCA</li>
	<li>Maximum Cardinality Matching</li>
	<li>Application Flow</li>
	<li>Min Path Cover Over Dag</li>
	<li>Independent Edge Disjoint Path</li>
	<li>Minimum Vertex Cover</li>
	<li>Maximum Independent Set</li>
</ol>
<b>Data Structures:</b>
<ol>
	<li>Arrays</li>
	<li>Linked List</li>
	<li>Trees (Binary Tree And Binary Search Tree)</li>
	<li>Stacks</li>
	<li>Queues</li>
	<li>Heap</li>
	<li>Hash Tables</li>
	<li>Disjoint-Set Data Structures</li>
	<li>Trie</li>
	<li>Segment Tree</li>
	<li>Binary Index Tree</li>
	<li>Treap</li>
</ol>
<b>Searching And Sorting:</b>
<ol>
	<li>Linear Search</li>
	<li>BInary Search</li>
	<li>Ternary Search</li>
	<li>Selection Sort</li>
	<li>Bubble Sort</li>
	<li>Insertion Sort</li>
	<li>Merge Sort</li>
	<li>Quick Sort</li>
	<li>Quick Select</li>
	<li>Heap Sort</li>
	<li>Radix Sort</li>
	<li>Counting Sort</li>
</ol>
<b>Greedy:</b>
Classical Problems of Greedy &amp; Concept
<b>example :</b> Fractional Knapsack

<b>Dynamic Programming Classical Problems</b>
<ol>
	<li>Edit Distance</li>
	<li>Egg Dropping Puzzle</li>
	<li>Integer Knapsack</li>
	<li>Largest Independent Set</li>
	<li>Longest Biotonic Subsequence</li>
	<li>Longest Common Subsequence</li>
	<li>Longest Common Substring</li>
	<li>Longest Increasing Subsequence</li>
	<li>Longest Palindromic Subsequence</li>
	<li>Longest Palindromic Substring</li>
	<li>Longest Substring Without Repeating Character</li>
	<li>Matrix Chain Multiplication</li>
	<li>Max Size Square Submatrix With One</li>
	<li>Maximum Length Chain Pairs</li>
	<li>Maximum Sum Increasing Subsequence</li>
	<li>Optimal Binary Search Tree</li>
	<li>Palindrome Partition Problem</li>
	<li>Set Partition Problem</li>
	<li>Subset Sum</li>
	<li>Word Wrap Problem</li>
</ol>
<b>Dynamic ProgrammingÂ  Advanced Techniques</b>
<ol>
	<li>DP + Tree</li>
	<li>DP + Bit Masking</li>
	<li>DP + Binary Search</li>
	<li>DP + Graph</li>
	<li>DP + Matrix Exponentiation</li>
	<li>DP + Probability Space</li>
	<li>DP + Crack Recurrence</li>
</ol>
<b>Divide &amp; Conquer</b>
Classical Problems &amp; Concepts
<ol>
	<li>Merge Sort</li>
	<li>Inversion Count</li>
	<li>Tromino Puzzle</li>
	<li>Closest Pair Points</li>
</ol>
<b>Other Algorithm Design Techniques :</b>
<ol>
	<li>BackTracking</li>
	<li>Man In Middle</li>
	<li>Newton-Raphson to reach the fixed point</li>
	<li>Brute Force</li>
	<li>Constructive Algo</li>
	<li>Sliding Window</li>
	<li>Pancake Sorting</li>
</ol>
</body>
</html>